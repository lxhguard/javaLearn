# 1. Java与C、C++之间的区别

java不需要手动申请内存、释放内存

# 2. GC

全称：Garbage Collection
Java 吸引人的地方：（1）一处书写到处运行。java编译生成字节码，JVM会调用底层（2）不需要手动申请内存、释放内存，即GC。

# 3. GC要做的事情

## 3-1. When/Where?

when：堆中的内存空间不够用
where：堆、方法区

## 3-2. Who?

GC如何判断对象的存活？（两种方法）
（1）引用计数算法(python)

缺点：循环引用没办法回收。

（2）可达性分析(Java,JS)

在Java，可作为GC Roots的对象包括：

- 1. 方法区中类静态属性引用的对象
- 2. 方法区中常量引用的对象
- 3. 虚拟机栈(本地变量表)中引用的对象
- 4. 本地方法栈中JNI(Native方法)中引用的对象。

JVM中各种引用(Reference)的区分：

- 1. 强引用：如 new 一个对象实例。
- 2. 软引用SoftReference：当堆中内存不足时，软引用的对象会被回收。应用场景，本地缓存。
- 3. 弱引用WeakReference：无论空间是否充足，都会回收弱引用对象。
- 4. 虚引用PhantomReference：虚引用是否存在对对象的存在无任何影响。作用是，当它被垃圾回收器回收的时候，我们能得到一个通知。应用场景，跟踪垃圾回收器的活动。

> Java OOM异常：内存溢出

## 3-3. How?

垃圾回收算法：

（1）复制算法(Copying)
举例子：一堆混合豆子，黑豆(可回收)和红豆(不可回收)，留下红豆。一堆豆子在左侧，捡出来红豆放在右侧，扫把扫左侧豆子进垃圾堆。
优点：简单高效，不会出现内存碎片问题
缺点： 1.内存利用率低，只有一半 2.存活对象比较多时效率会明显降低
（2）标记-清除算法(Mark-Sweep)
举例子：一堆混合豆子，黑豆(可回收)和红豆(不可回收)，留下红豆。一堆豆子在面前，一个一个捡出来黑色豆子扔进垃圾堆。
方案：标记不可回收内存，清除不含标记的内存。
优点：利用率100%
缺点： 1.标记和清除的效率都不高(比对复制算法) 2.会产生大量的不连续的内存碎片
（2）标记-整理算法(Mark-Compact)
优点： 1.利用率100% 2.没有内存碎片
缺点： 1.标记和清除的效率都不高 2.效率相对标记-清除要低

> IBM做过一个调查，90%的对象是属于“朝生夕死”的(新生代)，只有10%的对象是需要存活下去的(老生代)。根据这种调查结果，所以大部分GC会把对象进行细分：新生代、老生代。

JVM的垃圾回收器，会把算法们都用上。
分代收集：

> 新生代：老生代 = 1:9  Eden:Survovor1:Survovor2 = 8:1:1  这两个比例可以通过XX、Xmn、XX进行调整的。
> 优先级: 1 > 2 > 3
> XX：NewRadio 3
> Xmn：Newsize = MaxNewSize = ?M 2
> XX：Newsize/MaxNewSize 1 

- 1.新生代(Eden伊甸园、Survivor)：大部分对象一出生就在新生代。使用**复制算法**。垃圾收集器常用ParNew。
> 新生代一般经过15次垃圾回收会晋升到老生代。
- 2.老生代：使用Mark-Sweep和Mark-Compact，称为**Full GC**。垃圾收集器常用CMS。

单线程、并发和并行：
并行：垃圾收集的多线程的同时进行。
并发：垃圾收集的多线程和应用的多线程同时进行。


# 4. 谁需要GC